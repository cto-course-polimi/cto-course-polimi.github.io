[< Index](index.html)

# Synopsis

In modern computer science and engineering, code transformation techniques are
critical to achieve the combined goals of combining programmer productivity and
program execution efficiency in terms of time and energy. Yet, it is a skill
mastered by few – there are less than 1.5 compiler construction expert for
every 1000 software engineers, but almost 2 jobs in compilers for every 100
in software engineering!

The course is designed to provide an overview of code transformation, analysis
and optimization techniques needed to effectively produce optimized code.

To compiler and EDA tool engineers, the course provides the basic tools to
design and implement compilers and other code transformation and analysis tools,
as well as an introduction to the most popular modern compiler framework, LLVM.

To software engineers, the course provides a grounding in system software
design and development, as well as insights on the benefits and limitations
of automation in software engineering. Moreover, as a compiler is a paramount
of complex software systems, it provides a hands-on introduction to the design
and implementation process for such systems. Finally, many advanced software
engineering techniques such as program slicing are implemented on top of
algorithms used in compiler construction.

To computer architects and embedded software engineers, the course provides
crucial insights on the power and limits of compiler optimization, as well
as to the need any processor architecture has of appropriate compilers.

To all computer science students, the course provides a “behind the scenes”
view of the operation of software, and its automated manipulation –
understanding compilers means being able to write better, more efficient code.

## Learning Goals

 - Understand the internal structure of a real-world compiler
 - Understand the effectiveness and limitations of code analysis and
   optimization techniques
 - Be able to construct a full compiler for a toy language, generating
   assembly code for a RISC architecture